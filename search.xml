<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据增强</title>
      <link href="post/paper/%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA/"/>
      <url>post/paper/%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%BC%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h1>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Augmentation </tag>
            
            <tag> Deep Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树与图</title>
      <link href="post/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%9B%BE/"/>
      <url>post/algorithm/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>#二叉树与图 </p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="post/algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>post/algorithm/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列</title>
      <link href="post/algorithm/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>post/algorithm/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">stack&lt;int&gt; S;</span><br><span class="line">if (S.empty())&#123;</span><br><span class="line">printf(&quot;S is empty!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">S.push(5);</span><br><span class="line">S.push(6);</span><br><span class="line">S.push(10);</span><br><span class="line">printf(&quot;S.top = %d\n&quot;, S.top());</span><br><span class="line">S.pop();</span><br><span class="line">S.pop();</span><br><span class="line">printf(&quot;S.top = %d\n&quot;, S.top());</span><br><span class="line">printf(&quot;S.size = %d\n&quot;, S.size());</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">queue&lt;int&gt; Q;</span><br><span class="line">if (Q.empty())&#123;</span><br><span class="line">printf(&quot;Q is empty!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Q.push(5);</span><br><span class="line">Q.push(6);</span><br><span class="line">Q.push(10);</span><br><span class="line">printf(&quot;Q.front = %d\n&quot;, Q.front());</span><br><span class="line">Q.pop();</span><br><span class="line">Q.pop();</span><br><span class="line">printf(&quot;Q.front = %d\n&quot;, Q.front());</span><br><span class="line">Q.push(1);</span><br><span class="line">printf(&quot;Q.back = %d\n&quot;, Q.back());</span><br><span class="line">printf(&quot;Q.size = %d\n&quot;, Q.size());</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    priority_queue&lt;int&gt; big_heap; //默认为最大堆</span><br><span class="line">    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; small_heap;//最小堆构造方法</span><br><span class="line">    priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; big_heap2;//最大堆构造方法</span><br><span class="line"></span><br><span class="line">    if (big_heap.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;big_heap is empty!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    int test[] = &#123;6, 10, 1, 7, 99, 4, 33&#125;;</span><br><span class="line">    for (int i = 0; i &lt; 7; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        big_heap.push(test[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;big_heap.top = %d\n&quot;, big_heap.top());</span><br><span class="line">    big_heap.push(1000);</span><br><span class="line">    printf(&quot;big_heap.top = %d\n&quot;, big_heap.top());</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 3; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        big_heap.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;big_heap.top = %d\n&quot;, big_heap.top());</span><br><span class="line">    printf(&quot;big_heap.size = %d\n&quot;, big_heap.size());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 7; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        small_heap.push(test[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;small_heap.top = %d\n&quot;, small_heap.top());</span><br><span class="line">    small_heap.push(-1);</span><br><span class="line">    printf(&quot;small_heap.top = %d\n&quot;, small_heap.top());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="例1-使用队列实现栈"><a href="#例1-使用队列实现栈" class="headerlink" title="例1:使用队列实现栈"></a>例1:使用队列实现栈</h3><p>请设计一个栈，支持如下操作：<br>1.push(x): 将元素x压入栈中。<br>2.pop(): 弹出(移除)栈顶元素。<br>3.top(): 返回栈顶元素。<br>4.empty(): 判断栈是否为空。<br>这些操作的算法复杂度需要是常数级，栈的内部存储数据的结构为队列，队列的方法只能包括push、peek(front)、pop、size、empty等标准的队列方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class MyStack &#123;</span><br><span class="line">public:</span><br><span class="line">    MyStack() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">    queue&lt;int&gt; temp_queue;</span><br><span class="line">    temp_queue.push(x);</span><br><span class="line">    //最后元素都在队列data中</span><br><span class="line">    while(!data.empty())&#123;</span><br><span class="line">    temp_queue.push(data.front());</span><br><span class="line">    data.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    while(!temp_queue.empty())&#123;</span><br><span class="line">   data.push(temp_queue.front());</span><br><span class="line">   temp_queue.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">        int x = data.front();</span><br><span class="line">    data.pop();</span><br><span class="line">    return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int top() &#123;</span><br><span class="line">        return data.front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return data.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">queue&lt;int&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">MyStack S;</span><br><span class="line">S.push(1);</span><br><span class="line">S.push(2);</span><br><span class="line">S.push(3);</span><br><span class="line">S.push(4);</span><br><span class="line">printf(&quot;%d\n&quot;, S.top());</span><br><span class="line">S.pop();</span><br><span class="line">printf(&quot;%d\n&quot;, S.top());</span><br><span class="line">S.push(5);</span><br><span class="line">printf(&quot;%d\n&quot;, S.top());</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例2-使用栈实现队列"><a href="#例2-使用栈实现队列" class="headerlink" title="例2:使用栈实现队列"></a>例2:使用栈实现队列</h3><p>请设计一个队列，队列支持如下操作：<br>1.push(x): 将元素x压入队列中。<br>2.pop(): 弹出(移除)队列头部元素。<br>3.peek(): 返回队列头部元素(即为front)。<br>4.empty(): 判断队列是否是空。<br>这些操作的算法复杂度需要是常数级，队列的内部存储数据的结构为栈，栈的方法只能包括push、top、pop、size、empty等标准的栈方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class MyQueue &#123;</span><br><span class="line">public:</span><br><span class="line">    MyQueue() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        stack&lt;int&gt; temp_stack;</span><br><span class="line">        //最后元素都存在于data栈中</span><br><span class="line">        while(!data.empty())&#123;</span><br><span class="line">        temp_stack.push(data.top());</span><br><span class="line">        data.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        temp_stack.push(x);</span><br><span class="line">        while(!temp_stack.empty())&#123;</span><br><span class="line">        data.push(temp_stack.top());</span><br><span class="line">        temp_stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int pop() &#123;</span><br><span class="line">    int x = data.top();</span><br><span class="line">    data.pop();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int peek() &#123;</span><br><span class="line">        return data.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool empty() &#123;</span><br><span class="line">        return data.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">stack&lt;int&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">MyQueue Q;</span><br><span class="line">Q.push(1);</span><br><span class="line">Q.push(2);</span><br><span class="line">Q.push(3);</span><br><span class="line">Q.push(4);</span><br><span class="line">printf(&quot;%d\n&quot;, Q.peek());</span><br><span class="line">Q.pop();</span><br><span class="line">printf(&quot;%d\n&quot;, Q.peek());</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例3-包含min函数的栈"><a href="#例3-包含min函数的栈" class="headerlink" title="例3:包含min函数的栈"></a>例3:包含min函数的栈</h3><p>设计一个栈，支持如下操作，这些操作的算法复杂度需要是常数级。<br>1.push(x): 将元素x压入栈中。<br>2.pop(): 弹出栈顶元素。<br>3.top(): 返回栈顶元素。<br>4.getMin(): 返回栈内最小元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class MinStack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    MinStack()&#123;&#125;</span><br><span class="line">    void push(int x)</span><br><span class="line">    &#123;</span><br><span class="line">        data_S.push(x);</span><br><span class="line">        if (min_S.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            min_S.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (x &gt; min_S.top())</span><br><span class="line">            &#123;</span><br><span class="line">                x = min_S.top();</span><br><span class="line">            &#125;</span><br><span class="line">            min_S.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pop()</span><br><span class="line">    &#123;</span><br><span class="line">        data_S.pop();</span><br><span class="line">        min_S.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int top()</span><br><span class="line">    &#123;</span><br><span class="line">        return data_S.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int getMin()</span><br><span class="line">    &#123;</span><br><span class="line">        return min_S.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    stack&lt;int&gt; data_S;</span><br><span class="line">    stack&lt;int&gt; min_S; //额外使用一个栈来记录栈中的最小值</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    MinStack minStack;</span><br><span class="line">    minStack.push(-2);</span><br><span class="line">    printf(&quot;top = [%d]\n&quot;, minStack.top());</span><br><span class="line">    printf(&quot;min = [%d]\n\n&quot;, minStack.getMin());</span><br><span class="line">    minStack.push(0);</span><br><span class="line">    printf(&quot;top = [%d]\n&quot;, minStack.top());</span><br><span class="line">    printf(&quot;min = [%d]\n\n&quot;, minStack.getMin());</span><br><span class="line">    minStack.push(-5);</span><br><span class="line">    printf(&quot;top = [%d]\n&quot;, minStack.top());</span><br><span class="line">    printf(&quot;min = [%d]\n\n&quot;, minStack.getMin());</span><br><span class="line">    minStack.pop();</span><br><span class="line">    printf(&quot;top = [%d]\n&quot;, minStack.top());</span><br><span class="line">    printf(&quot;min = [%d]\n\n&quot;, minStack.getMin());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例4-合法的出栈序列"><a href="#例4-合法的出栈序列" class="headerlink" title="例4:合法的出栈序列"></a>例4:合法的出栈序列</h3><p>已知从1至n的数字序列，按顺序入栈，每个数字入栈后即可出栈，也可在栈中停留，等待后面的数字入栈出栈后，该数字再出栈，求该数字序列的出栈序列是否合法？</p><p>思路:<br>1.出栈序列存储在队列order中。<br>2.按元素顺序,将元素push进入栈。<br>3.每push一个元素，即检查是否与队列首部元素相同，若相同则弹出队列首元素，弹出栈顶元素，直到两元素不同结束。<br>4.若最终栈为空，说明序列合法，否则不合法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool check_is_valid_order(queue&lt;int&gt; &amp;order)</span><br><span class="line">&#123;</span><br><span class="line">    stack&lt;int&gt; S;</span><br><span class="line">    int n = order.size();</span><br><span class="line">    for (int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        S.push(i);</span><br><span class="line">        while(!S.empty() &amp;&amp; order.front() == S.top())</span><br><span class="line">        &#123;</span><br><span class="line">            S.pop();</span><br><span class="line">            order.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    int train;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    while(n)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;train);</span><br><span class="line">        while (train)</span><br><span class="line">        &#123;</span><br><span class="line">            queue&lt;int&gt; order;</span><br><span class="line">            order.push(train);</span><br><span class="line">            for (int i = 1; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                scanf(&quot;%d&quot;, &amp;train);</span><br><span class="line">                order.push(train);</span><br><span class="line">            &#125;</span><br><span class="line">            if (check_is_valid_order(order))</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;Yes\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;No\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;train);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例5-简单的计算器"><a href="#例5-简单的计算器" class="headerlink" title="例5:简单的计算器"></a>例5:简单的计算器</h3><p>设计一个计算器，输入一个字符串存储的数学表达式，可以计算包括“(“,”)”,”+”,”-”四种符号的数学表达式，<br>输入的数学表达式字符串保证是合法的，输入的数学表达式中可能存在空格字符。</p><p>思路：<br>1.使用状态转换机。<br>2.使用两个栈,分被用来存放数字和符号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int calculate(string s)</span><br><span class="line">    &#123;</span><br><span class="line">        static const int STATE_BEGIN = 0;</span><br><span class="line">        static const int NUMBER_STATE = 1;</span><br><span class="line">        static const int OPERATION_STATE = 2;</span><br><span class="line"></span><br><span class="line">        stack&lt;int&gt; number_stack;</span><br><span class="line">        stack&lt;char&gt; operation_stack;</span><br><span class="line">        int number = 0;</span><br><span class="line">        int STATE = STATE_BEGIN;</span><br><span class="line">        int compuate_flag = 0;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (s[i] == &#x27; &#x27;)</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //状态转换</span><br><span class="line">            switch(STATE)</span><br><span class="line">            &#123;</span><br><span class="line">            case STATE_BEGIN:</span><br><span class="line">                if (s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    STATE = NUMBER_STATE;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    STATE = OPERATION_STATE;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case NUMBER_STATE:</span><br><span class="line">                if (s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    number = number * 10 + s[i] - &#x27;0&#x27;;</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    number_stack.push(number);</span><br><span class="line">                    if (compuate_flag == 1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        compute(number_stack, operation_stack);</span><br><span class="line">                    &#125;</span><br><span class="line">                    number = 0;</span><br><span class="line">                    i--;</span><br><span class="line">                    STATE = OPERATION_STATE;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case OPERATION_STATE:</span><br><span class="line">                if (s[i] == &#x27;+&#x27; || s[i] == &#x27;-&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    operation_stack.push(s[i]);</span><br><span class="line">                    compuate_flag = 1;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (s[i] == &#x27;(&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    STATE = NUMBER_STATE;</span><br><span class="line">                    compuate_flag = 0;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    STATE = NUMBER_STATE;</span><br><span class="line">                    i--;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (s[i] == &#x27;)&#x27;)</span><br><span class="line">                &#123;</span><br><span class="line">                    compute(number_stack, operation_stack);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (number != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            number_stack.push(number);</span><br><span class="line">            compute(number_stack, operation_stack);</span><br><span class="line">        &#125;</span><br><span class="line">        if (number == 0 &amp;&amp; number_stack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return number_stack.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    //计算函数</span><br><span class="line">    void compute(stack&lt;int&gt; &amp;number_stack,stack&lt;char&gt; &amp;operation_stack)</span><br><span class="line">    &#123;</span><br><span class="line">        if (number_stack.size() &lt; 2)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        int num2 = number_stack.top();</span><br><span class="line">        number_stack.pop();</span><br><span class="line">        int num1 = number_stack.top();</span><br><span class="line">        number_stack.pop();</span><br><span class="line">        if (operation_stack.top() == &#x27;+&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            number_stack.push(num1 + num2);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(operation_stack.top() == &#x27;-&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            number_stack.push(num1 - num2);</span><br><span class="line">        &#125;</span><br><span class="line">        operation_stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    string s = &quot;1 + 121-(14+(5-6))&quot;;</span><br><span class="line">    Solution solve;</span><br><span class="line">    printf(&quot;%d\n&quot;, solve.calculate(s));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例6-数组中第K大的数"><a href="#例6-数组中第K大的数" class="headerlink" title="例6:数组中第K大的数"></a>例6:数组中第K大的数</h3><p>已知一个未排序的数组，求这个数组中第K大的数字。如array = [3,2,1,5,6,4], k = 2, return 5。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Solution</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    int findKthLargest(vector&lt;int&gt;&amp; nums, int k)</span><br><span class="line">    &#123;</span><br><span class="line">        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; Q; //最小堆（队头最小）</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (Q.size() &lt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                Q.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (Q.top() &lt; nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                Q.pop();</span><br><span class="line">                Q.push(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return Q.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">vector&lt;int&gt; nums;</span><br><span class="line">nums.push_back(3);</span><br><span class="line">nums.push_back(2);</span><br><span class="line">nums.push_back(1);</span><br><span class="line">nums.push_back(5);</span><br><span class="line">nums.push_back(6);</span><br><span class="line">nums.push_back(4);</span><br><span class="line">Solution solve;</span><br><span class="line">printf(&quot;%d\n&quot;, solve.findKthLargest(nums, 2));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例7-寻找中位数"><a href="#例7-寻找中位数" class="headerlink" title="例7:寻找中位数"></a>例7:寻找中位数</h3><p>设计一个数据结构，该数据结构动态维护一组数据，且支持如下操作:<br>1.添加元素: void addNum(int num)，将整型num添加至数据结构中。<br>2.返回数据的中位数: double findMedian()，返回其维护的数据的中位数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class MedianFinder</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    MedianFinder()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    void addNum(int num)</span><br><span class="line">    &#123;</span><br><span class="line">        if (big_queue.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            big_queue.push(num);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (big_queue.size() == small_queue.size())</span><br><span class="line">        &#123;</span><br><span class="line">            //保持最小堆堆顶大于最大堆堆顶</span><br><span class="line">            if (num &lt; big_queue.top())</span><br><span class="line">            &#123;</span><br><span class="line">                big_queue.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                small_queue.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //始终保持两堆大小最多只相差一</span><br><span class="line">        else if(big_queue.size() &gt; small_queue.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if (num &gt; big_queue.top())</span><br><span class="line">            &#123;</span><br><span class="line">                small_queue.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                small_queue.push(big_queue.top());</span><br><span class="line">                big_queue.pop();</span><br><span class="line">                big_queue.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(big_queue.size() &lt; small_queue.size())</span><br><span class="line">        &#123;</span><br><span class="line">            if (num &lt; small_queue.top())</span><br><span class="line">            &#123;</span><br><span class="line">                big_queue.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                big_queue.push(small_queue.top());</span><br><span class="line">                small_queue.pop();</span><br><span class="line">                small_queue.push(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    double findMedian()</span><br><span class="line">    &#123;</span><br><span class="line">        if (big_queue.size() == small_queue.size())</span><br><span class="line">        &#123;</span><br><span class="line">            return (big_queue.top() + small_queue.top()) / 2;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (big_queue.size() &gt; small_queue.size())</span><br><span class="line">        &#123;</span><br><span class="line">            return big_queue.top();</span><br><span class="line">        &#125;</span><br><span class="line">        return small_queue.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    priority_queue&lt;double,vector&lt;double&gt;,less&lt;double&gt;&gt; big_queue; //最大堆</span><br><span class="line">    priority_queue&lt;double,vector&lt;double&gt;,greater&lt;double&gt;&gt; small_queue; //最小堆</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    MedianFinder M;</span><br><span class="line">    int test[] = &#123;6, 10, 1, 7, 99, 4, 33&#125;;</span><br><span class="line">    for (int i = 0; i &lt; 7; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        M.addNum(test[i]);</span><br><span class="line">        printf(&quot;%lf\n&quot;, M.findMedian());</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="post/algorithm/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>post/algorithm/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>#贪心算法</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表练习</title>
      <link href="post/algorithm/%E9%93%BE%E8%A1%A8%E7%BB%83%E4%B9%A0/"/>
      <url>post/algorithm/%E9%93%BE%E8%A1%A8%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>#链表练习</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归-回溯-分治</title>
      <link href="post/algorithm/%E9%80%92%E5%BD%92-%E5%9B%9E%E6%BA%AF-%E5%88%86%E6%B2%BB/"/>
      <url>post/algorithm/%E9%80%92%E5%BD%92-%E5%9B%9E%E6%BA%AF-%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<p>#递归-回溯-分治</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表基础</title>
      <link href="post/algorithm/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80/"/>
      <url>post/algorithm/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>#链表基础</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
